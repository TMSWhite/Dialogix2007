/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:\cvs5\Dialogix2007\Dialogix_J2EE\DialogixCore\src\org\dianexus\triceps\parser\DialogixParser.jj */
/*@egen*//* ******************************************************** 
** Copyright (c) 2000-2008, Thomas Maxwell White, all rights reserved. 
******************************************************** */ 

options {
  LOOKAHEAD=1;
  STATIC=false;  
  UNICODE_INPUT = true;	// this seems to require UTF-16
}


PARSER_BEGIN(DialogixParser)

package org.dianexus.triceps.parser;
import java.io.*;
import java.util.*;
import org.dianexus.triceps.*;
import java.util.logging.*;

/**
  This is the main function for implementing the JavaCC and JJTree-based parser.
  It is a subset of C designed to only process Statements.
  It is specifically geared to use Datum objects, which are loosely typed, but also store special Missing value options.
  
  Usage:
  (1) Call init or ReInit functions, which specify the equation, which will come from an input source (a form of Reader)
  (2) Call parse function to evaluate the selected equation and return a Datum
  (3) Optionally call getErrors() to see any syntax errors
  (4) Optionally call getDependencies() to see which variables are references within the equation
  
  
  TODO:  Can this be implemented as a Pool of parsers?
  TODO:  Can the logging be Triceps specific to show equatation specific error messages?  (Rather than using ArrayList of errorMessages?)
  
  @see Datum
*/

public class DialogixParser implements/*@bgen(jjtree)*/ DialogixParserTreeConstants, /*@egen*/ Serializable, VersionIF   {/*@bgen(jjtree)*/
  protected JJTDialogixParserState jjtree = new JJTDialogixParserState();

/*@egen*/
  private Stack stack;
  private Triceps triceps;
  private Logger logger = Logger.getLogger("org.dianexus.triceps.parser.DialogixParser");  /* XXX:  Do I need way to have triceps-specific logger? */
  private Hashtable dependencies;  // list of variables from this equation
  private ArrayList errorMessages;
  
  /**
    The main function for evaluating the desired equation(s).
    
    @param  tri  The triceps
    @return The Datum representing the result of parsing the equation
  */
  public Datum parse(Triceps tri) {
    triceps = tri;
    Datum d = null;

    try {
      stack = new Stack();
      dependencies = new Hashtable();
      errorMessages = new ArrayList();
      Statement();
      d = (Datum) stackPop();
      /* If the stack has anything left on it, then there was a parse exception */
      /* Likewise, if last token was not <EOF>, then tokens left on stack? */
      if (stack.size() > 0) {
        StringBuffer sb = new StringBuffer(((Datum) stackPop()).stringVal());
        while (stack.size() > 0) {
          sb.append(((Datum) stackPop()).stringVal());
        }
        error("Syntax error -- extra characters found: " + sb.toString());
      }
    }
    catch (EmptyStackException e) {
      error(triceps.get("stack_underflow"),token.beginLine,token.beginColumn);
      }
    catch (ParseException e) {
      error(e.getMessage());
    }
    catch (TokenMgrError e) {
      error(e.getMessage());
    }
    
    if (logger.isLoggable(Level.FINEST)) {
      trace(null,d);
    }

    return ((d != null) ? d : new Datum(Datum.INVALID,triceps));
  }
  
  /**
    @return The list of errors, if any
  */
  public Collection getErrors() { 
    return errorMessages; 
  }
  
  /**
    @return The number of syntax errors found, if any
  */
  public int numErrors() { 
    return errorMessages.size(); 
  }
  
  /**
    @return The list of variable names used in this equation, if any
  */
  public Collection getDependencies() { 
    ArrayList al = new ArrayList(dependencies.values());
    Collections.sort(al);
    return al;
  }
  
  /**
    @return The number of variable names used within the equation
  */
  public int numDependencies() { 
    return dependencies.size(); 
  }

  /**
    Log an error message
    
    @param  s The error message
  */
  private void error(String s) { 
    logger.log(Level.SEVERE,s);
    errorMessages.add(s);
  }
  
  /**
    Log an error message, including line number
    
    @param  s The message
    @param  line  The line number
    @param  column  The column number at which the error occured
  */
  private void error(String s, int line, int column) {
    String msg = "[" + line + ":" + column + "]" + s;
    logger.log(Level.SEVERE,msg);
    errorMessages.add(msg);
  }

  /**
    Prints stack trace in tab delimited format - operator, arguments, ->, answer
    
    @param  s The message
    @param  d The Datum value containing the answer
  */
  private void trace(String s,Datum d) {
    if (logger.isLoggable(Level.FINEST)) {
      if (d == null) {
        logger.log(Level.FINEST,s + "[null Datum]");
      }
      else {
        String varName = d.getName();
        
        logger.log(Level.FINEST,((s != null) ? (s + "\t") : "") + "->\t" +
              "'" + d.stringVal(true) + "'\t" + 
              d.doubleVal() + "\t" + 
              d.dateVal() + "\t" + 
              d.monthVal() + "\t" +
              ((varName != null) ? ("VAR_NAME='" + varName + "'") : ""));
      }
    }
  }

  /**
    Returns a formated view of the Datum's value.
    
    @param  d The Datum
    @return The formatted value
    @see Datum
  */
  private String datumValue(Datum d) {
    String varName = d.getName();
    if (varName == null)
      return d.stringVal(true);
    else
      return ("(" + varName + "," + d.stringVal(true) + ")");
  }

  /**
    Returns the name of the operator used to parse the equation, for tracing purposes.
    
    @param  op  The operator
    @return The human-readable name of the operator
  */
  private String opName(int op) {
    return tokenImage[op].substring(1,tokenImage[op].length()-1);
  }
  
  /**
    Process an unary operator (+,-,!), pushing the result on the stack.
    
    @param  op  The operator
    @param  arg1  it's argument
  */
  private void unaryOp(int op, Object arg1) {
    Datum a = getParam(arg1);
    Datum ans = null;
    switch(op) {
      case PLUS: ans = a; break;
      case MINUS: ans = (new DatumMath()).neg(a); break;
      case NOT: ans = (new DatumMath()).not(a); break;
      default: ans = new Datum(Datum.INVALID,triceps); break;
    }
    stackPush(ans);

    if (logger.isLoggable(Level.FINEST)) {
      trace(opName(op) + "\t" + datumValue(a),ans);
    }
  }

  /**
    Safely get a Datum, returning INVALID if it is null.
    
    @param  o The parameter
  */
  private Datum getParam(Object o) {
    if (o == null)
      return new Datum(Datum.INVALID,triceps);
    return (Datum) o;
  }

  /**
    Process a binary operator (+,-,*,/,>, etc., pushing the result on the stack
    
    @param  op  The operator
    @param  arg2  The right hand side of the equation
    @param  arg1  The left hand side of the equation
  */
  private void binaryOp(int op, Object arg2, Object arg1) {
    Datum a = getParam(arg1);
    Datum b = getParam(arg2);
    Datum ans = null;
    switch(op) {
      case PLUS: ans = (new DatumMath()).add(a,b); break;
      case MINUS: ans = (new DatumMath()).subtract(a,b); break;
      case MULTIPLY: ans = (new DatumMath()).multiply(a,b); break;
      case DIVIDE: ans = (new DatumMath()).divide(a,b); break;
      case GT: ans = (new DatumMath()).gt(a,b); break;
      case GE: ans = (new DatumMath()).ge(a,b); break;
      case EQ: ans = (new DatumMath()).eq(a,b); break;
      case NEQ: ans = (new DatumMath()).neq(a,b); break;
      case LT: ans = (new DatumMath()).lt(a,b); break;
      case LE: ans = (new DatumMath()).le(a,b); break;
      case CONCATENATE: ans = (new DatumMath()).concat(a,b); break;
      case ANDAND: ans = (new DatumMath()).andand(a,b); break;
      case OROR: ans = (new DatumMath()).oror(a,b); break;
      case MODULUS: ans = (new DatumMath()).modulus(a,b); break;
      case XOR: ans = (new DatumMath()).xor(a,b); break;
      case AND: ans = (new DatumMath()).and(a,b); break;
      case OR: ans = (new DatumMath()).or(a,b); break;
      case ASSIGN: triceps.getEvidence().set(a.stringVal(),b); ans = triceps.getEvidence().getDatum(a.stringVal()); break;
      default: ans = new Datum(Datum.INVALID,triceps); break;
    }
    stackPush(ans);
    
    if (logger.isLoggable(Level.FINEST)) {
      trace(opName(op) + "\t" + datumValue(a) + "\t" + datumValue(b),ans);
    }
  }

  /**
    Process a ternary operator, like (eqn) ? true : false, pushing the result on the stack
    
    @param  op  The operator
    @param  arg3  The 3rd argument
    @param  arg2  The 2nd argument
    @param  arg1  The 1st argument
  */
  private void trinaryOp(int op, Object arg3, Object arg2, Object arg1) {
    Datum a = getParam(arg1);
    Datum b = getParam(arg2);
    Datum c = getParam(arg3);
    Datum ans = null;
    switch(op) {
      case QUEST: ans = (new DatumMath()).conditional(a,b,c); break;
      default: ans = new Datum(Datum.INVALID,triceps); break;
    }
    stackPush(ans);

    if (logger.isLoggable(Level.FINEST)) {
      trace(opName(op) + "\t" + datumValue(a) + "\t" + datumValue(b) + "\t" + datumValue(c),ans);
    }
  }
  
  /**
    Perform a function on a stack of arguments, pushing the result on the stack
    
    @param  func  The requested function
    @param  params  The stack of parameters
  */
  private void functionOp(Token func, Stack params) {
    Datum ans = triceps.getEvidence().function(func.image, params, func.beginLine, func.beginColumn);
    stackPush(ans);

    if (logger.isLoggable(Level.FINEST)) {
      StringBuffer sb = new StringBuffer("function\t" + func.image);
      for (int i=0;i<params.size();++i) {
        Object o = params.elementAt(i);
        if (o == null)
          sb.append("\tnull");
        else if (o instanceof Datum)
          sb.append("\t" + datumValue((Datum) o));
        else if (o instanceof String)
          sb.append("\t" + (String) o);
        else
          sb.append("\t" + o.getClass());
      }
      trace(sb.toString(), ans);
    }
  }
  
  /**
    Check whether a value matches any of the values in a list.
    
    @param result The value to match
    @param set  The set of objects to search
  */
  private void inListOp(Object result, Stack set) {
    Datum a = getParam(result);
    ArrayList set2 = null;
    
    if (logger.isLoggable(Level.FINEST)) {
    /*
      trace("LHS = ", a);
      set2 = new ArrayList(set);
      for (int i=0;i<set.size();++i) {
        trace("RHS[" + i + "] = ", triceps.getParam(set2.get(i)));
      }
      */
    }
    
    set2 = new ArrayList(set);
    for (int i=0;i<set.size();++i) {
      Datum b = triceps.getEvidence().getParam(set2.get(i));
      Datum ans = (new DatumMath()).eq(a,b);
      if (ans.booleanVal() == true) {
        stackPush(new Datum(triceps, true));
        return;
      }
    }
    stackPush(new Datum(triceps, false));
  }
  
  /**
    Push an operator, Datum, or function onto the stack, optionally logging it to the traceger
    
    @param  obj The object to push on the stack
  */
  private void stackPush(Object obj) {
    trace("Push",(Datum) obj);  // XXX:  Can this crash with case to Datum?
    stack.push(obj);
  }
  
  /**
    Pop an operator, Datum, or function from the stack, optionally logging it to the traceger
    
    @return The object
  */
  private Object stackPop() {
    Object obj = stack.pop();
    trace("Pop", (Datum) obj); // XXX:  Can this crash with cast to Datum?
    return obj;
  }
}

PARSER_END(DialogixParser)


TOKEN :
{
  < CHARACTER_LITERAL:
    "'"
    (  (~["'","\\","\n","\r"])
    | ("\\"
      ( ["n","t","b","r","f","\\","'","\""]
      )
      )
    )*
    "'"
  >
|
  < STRING_LITERAL:
    "\""
    (  (~["\"","\\","\n","\r"])
    | ("\\"
      ( ["n","t","b","r","f","\\","'","\""]
      )
      )
    )*
    "\""
  >
}

TOKEN : /* unary operatorrs */
{
  < PLUS: "+" >
|  < MINUS: "-" >
|  < NOT: "!" >

}

TOKEN : /* binary operators */
{
/* |  < PLUS: "+" > */
/* |  < MINUS: "-" > */

  < MULTIPLY: "*" >
|  < DIVIDE: "/" >
|  < GT: ">" | "gt" >
|  < GE: ">=" | "ge" >
|  < EQ: "==" | "eq" >
|  < NEQ: "!=" | "ne" >
|  < LT: "<" | "lt" >
|  < LE:  "<=" | "le" >
|  < CONCATENATE: "." >
|  < ANDAND: "&&" | "and" >
|  < OROR: "||" | "or" >
|  < MODULUS: "%" | "mod" >
|  < XOR: "^" | "xor" >
|  < AND: "&" | "bitwiseAnd" >
|  < OR: "|" | "bitwiseOr" >
|  < ASSIGN: "=" >
|  < IN: "in" >
}

TOKEN : /* ctxnary operators */
{
  < QUEST: "?" >
|  < COLON: ":" >
}

TOKEN : /* separator characters */
{
  < COMMA: "," >
|  < LP: "(" >
|  < RP: ")" >
|  < LSB: "[" >
|  < RSB: "]" >
|  < LCB: "{" >
|  < RCB: "}" >
|  < SEMICOLON: ";" >
}

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

TOKEN : /* numeric constants */
{
  <INTEGER_LITERAL: <DECIMAL_LITERAL> | <HEX_LITERAL> | <OCTAL_LITERAL> >
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
}

TOKEN : /* Function names */
{
  <  NMTOKEN:  ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
}

/**
  Process one or more statements
*/
void Statement() : {/*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
  try {
/*@egen*/
  Expressions() 
    ( LOOKAHEAD(2)
      <SEMICOLON> Expressions() 
        {
          Object value = stackPop();
          stackPop();  /* throw away the penultimate item on the stack */
          stackPush(value);
        }
    )*
  ( <SEMICOLON> )?
  <EOF>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process a set of expressions
*/
void Expressions() : {/*@bgen(jjtree) Expressions */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expressions */
  try {
/*@egen*/
  Expression()
    (
      <COMMA> Expression()
        {
          Object value = stackPop();
          stackPop();  /* throw away the penultimate item on the stack */
          stackPush(value);
        }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process a single expression, including conditionals
*/
void Expression() : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  LOOKAHEAD(2) AssignmentExpression()
|  ConditionalExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


/**
  Process "a = result"
*/
void AssignmentExpression(): {/*@bgen(jjtree) AssignmentExpression */
                               SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTEXPRESSION);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) AssignmentExpression */
  try {
/*@egen*/
  <NMTOKEN> { t = token; } <ASSIGN> ConditionalExpression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      binaryOp(ASSIGN,stackPop(), new Datum(triceps, t.image,Datum.STRING));
      dependencies.put(t.image,t.image);
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "(exp) ? true : false"
*/
void ConditionalExpression() : {/*@bgen(jjtree) ConditionalExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConditionalExpression */
  try {
/*@egen*/
  LogicalORExpression()
    (
      <QUEST> LogicalORExpression() <COLON> LogicalORExpression()
        { trinaryOp(QUEST,stackPop(),stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a || b"
*/
void LogicalORExpression() : {/*@bgen(jjtree) LogicalORExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTLOGICALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalORExpression */
  try {
/*@egen*/
  LogicalANDExpression()
    (
      <OROR> LogicalANDExpression()
        { binaryOp(OROR,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a && b"
*/
void LogicalANDExpression() : {/*@bgen(jjtree) LogicalANDExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTLOGICALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalANDExpression */
  try {
/*@egen*/
  InclusiveORExpression()
    (
      <ANDAND> InclusiveORExpression()
        { binaryOp(ANDAND,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process an expression like "a || b"
*/
void InclusiveORExpression() : {/*@bgen(jjtree) InclusiveORExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTINCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InclusiveORExpression */
  try {
/*@egen*/
  ExclusiveORExpression()
    (
      <OR> ExclusiveORExpression()
        { binaryOp(OR,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a | b"
*/
void ExclusiveORExpression() : {/*@bgen(jjtree) ExclusiveORExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExclusiveORExpression */
  try {
/*@egen*/
  ANDExpression()
    (
      <XOR> ANDExpression()
        { binaryOp(XOR,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a & b"
*/
void ANDExpression() : {/*@bgen(jjtree) ANDExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ANDExpression */
  try {
/*@egen*/
  EqualityExpression()
    ( 
      <AND> EqualityExpression()
        { binaryOp(AND,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a == b" and "a != b"
*/
void EqualityExpression() : {/*@bgen(jjtree) EqualityExpression */
                              SimpleNode jjtn000 = new SimpleNode(JJTEQUALITYEXPRESSION);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token op; }
{/*@bgen(jjtree) EqualityExpression */
  try {
/*@egen*/
  InListExpression()
    (
      ( <EQ> | <NEQ> ) { op = token; } InListExpression()
        { binaryOp(op.kind,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a in (b,c,d,e)"
*/
void InListExpression() : {/*@bgen(jjtree) InListExpression */
                            SimpleNode jjtn000 = new SimpleNode(JJTINLISTEXPRESSION);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token op; Stack params; }
{/*@bgen(jjtree) InListExpression */
  try {
/*@egen*/
  RelationalExpression()
    (
      <IN> <LP> ( params = FunctionParameters()) <RP>
        {
          inListOp(stackPop(),params);
        }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a op b" where op in {lt, gt, le, ge)
*/
void RelationalExpression() : {/*@bgen(jjtree) RelationalExpression */
                                SimpleNode jjtn000 = new SimpleNode(JJTRELATIONALEXPRESSION);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token op; }
{/*@bgen(jjtree) RelationalExpression */
  try {
/*@egen*/
  AdditiveExpression()
    (
      ( <LT> | <GT> | <LE> | <GE> ) { op = token; } AdditiveExpression()
        { binaryOp(op.kind,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a op b" where op in (+,-,concatenate)
*/
void AdditiveExpression() : {/*@bgen(jjtree) AdditiveExpression */
                              SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token op; }
{/*@bgen(jjtree) AdditiveExpression */
  try {
/*@egen*/
  MultiplicativeExpression()
    ( 
      ( <PLUS> | <MINUS> | <CONCATENATE> ) { op = token;} MultiplicativeExpression()
        { binaryOp(op.kind,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "a op b" where op in (*,/)
*/
void MultiplicativeExpression() : {/*@bgen(jjtree) MultiplicativeExpression */
                                    SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token op; }
{/*@bgen(jjtree) MultiplicativeExpression */
  try {
/*@egen*/
  UnaryExpression()
    ( 
      ( <MULTIPLY> | <DIVIDE> ) { op = token; } UnaryExpression()
        { binaryOp(op.kind,stackPop(),stackPop()); }
    )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process "op a" where op in (+,-,!)
*/
void UnaryExpression() : {/*@bgen(jjtree) UnaryExpression */
                           SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/ Token op; }
{/*@bgen(jjtree) UnaryExpression */
  try {
/*@egen*/
  (<PLUS> | <MINUS> | <NOT>) { op = token; } PrimaryExpression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { unaryOp(op.kind,stackPop()); }
|  PrimaryExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process an expression, including functions 
*/
void PrimaryExpression() : {/*@bgen(jjtree) PrimaryExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) PrimaryExpression */
  try {
/*@egen*/
  LOOKAHEAD(2) Function()
|  Constant()
|  <NMTOKEN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      Datum d = triceps.getEvidence().getDatum(token.image);
      if (d == null) {
        error(triceps.get("undefined_variable") + " '" + token.image + "'", token.beginLine, token.beginColumn);
        stackPush(new Datum(Datum.INVALID,triceps));
      }
      else {
        stackPush(d);
      }
      dependencies.put(token.image,token.image);  // pushes the name of the variables references within the equation.
    }
|  <LP> Expressions() <RP>
|  <LCB> Expressions() <RCB>
|  <LSB> Expressions() <RSB>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process a constant, including strings
*/
void Constant() : {/*@bgen(jjtree) Constant */
  SimpleNode jjtn000 = new SimpleNode(JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Constant */
  try {
/*@egen*/
  ( <INTEGER_LITERAL> |<FLOATING_POINT_LITERAL> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { stackPush(new Datum(triceps, token.image,Datum.NUMBER)); }
|  ( <STRING_LITERAL> | <CHARACTER_LITERAL> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      /* replace special characters before storing value */
      StringBuffer sb = new StringBuffer();
      char c;
      int i=0;

      try {
        for (i=1;i<token.image.length()-1;++i) {
          c = token.image.charAt(i);
          if (c == '\\') {
            c = token.image.charAt(++i);
            switch (c) {
              case 'b': sb.append('\b'); break;
              case 'f': sb.append('\f'); break;
              case 'n': sb.append('\n'); break;
              case 'r': sb.append('\n'); break;
              case 't': sb.append('\t'); break;
              case '\'': sb.append('\''); break;
              case '\"': sb.append('\"'); break;
              case '\\': sb.append('\\'); break;
              default: sb.append(c); break;
            }
          }
          else {
            sb.append(c);
          }
        }
      }
      catch (IndexOutOfBoundsException e) {
        error(triceps.get("unterminated_escaped_character"), token.beginLine, token.beginColumn + i);
      }

      stackPush(new Datum(triceps, sb.toString(),Datum.STRING));
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Process a function, passing the FunctionParameters as a stack to Functions.function
*/
void Function() : {/*@bgen(jjtree) Function */
                    SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; Stack params; }
{/*@bgen(jjtree) Function */
  try {
/*@egen*/
  <NMTOKEN> { t = token; } <LP> ( params = FunctionParameters()) <RP>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      functionOp(t,params);
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
  Assemble the stack of function parameters.
  
  @return The stack of parameters
*/
Stack FunctionParameters() : {/*@bgen(jjtree) FunctionParameters */
                               SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONPARAMETERS);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Stack params = new Stack(); }
{/*@bgen(jjtree) FunctionParameters */
  try {
/*@egen*/
  Expression()
    { params.push(stackPop()); }
  (
    "," Expression()
      { params.push(stackPop()); }
  )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return params; }
|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  /* empty */
  { return params; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
