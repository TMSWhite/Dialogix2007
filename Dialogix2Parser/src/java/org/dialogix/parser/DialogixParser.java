/* Generated By:JJTree&JavaCC: Do not edit this line. DialogixParser.java */
package org.dialogix.parser;
import java.io.*;
import java.util.*;
import java.lang.StringBuffer;
import java.util.logging.*;

/**
  This is the main function for implementing the JavaCC and JJTree-based parser.
  It is a subset of C designed to only process Statements.
  It is specifically geared to use Datum objects, which are loosely typed, but also store special Missing value options.
  
  Usage:
  (1) Call init or ReInit functions, which specify the equation, which will come from an input source (a form of Reader)
  (2) Call parse function to evaluate the selected equation and return a Datum
  (3) Optionally call getErrors() to see any syntax errors
  (4) Optionally call getDependencies() to see which variables are references within the equation
  
  
  TODO:  Can this be implemented as a Pool of parsers?
  TODO:  Can the logging be Context specific to show equatation specific error messages?  (Rather than using ArrayList of errorMessages?)
  
  @see Datum
*/

public class DialogixParser implements/*@bgen(jjtree)*/ DialogixParserTreeConstants,Serializable, DialogixParserConstants {/*@bgen(jjtree)*/
  protected JJTDialogixParserState jjtree = new JJTDialogixParserState();private Stack stack;
  private Context context;
  static Logger logger = Logger.getLogger("org.dialogix.parser.DialogixParser");
  private Hashtable dependencies;  // list of variables from this equation
  private ArrayList errorMessages;

  /**
    The main function for evaluating the desired equation(s).
    
    @param  ctx  The context
    @return The Datum representing the result of parsing the equation
  */
  public Datum parse(Context ctx) {
    context = ctx;
    Datum d = null;

    try {
      stack = new Stack();
      dependencies = new Hashtable();
      errorMessages = new ArrayList();
      Statement();
      d = (Datum) stackPop();
      /* If the stack has anything left on it, then there was a parse exception */
      /* Likewise, if last token was not <EOF>, then tokens left on stack? */
      if (stack.size() > 0) {
        StringBuffer sb = new StringBuffer(((Datum) stackPop()).stringVal());
        while (stack.size() > 0) {
          sb.append(((Datum) stackPop()).stringVal());
        }
        error("Syntax error -- extra characters found: " + sb.toString());
      }
    }
    catch (EmptyStackException e) {
      error(context.get("stack_underflow"),token.beginLine,token.beginColumn);
      }
    catch (ParseException e) {
      error(e.getMessage());
    }
    catch (TokenMgrError e) {
      error(e.getMessage());
    }

    if (logger.isLoggable(Level.FINE)) {
      debug(null,d);
    }

    return ((d != null) ? d : Datum.getInstance(context,Datum.INVALID));
  }

  /**
    @return The list of errors, if any
  */
  public Collection getErrors() {
    return errorMessages;
  }

  /**
    @return The number of syntax errors found, if any
  */
  public int numErrors() {
    return errorMessages.size();
  }

  /**
    @return The list of variable names used in this equation, if any
  */
  public Collection getDependencies() {
    ArrayList al = new ArrayList(dependencies.values());
    Collections.sort(al);
    return al;
  }

  /**
    @return The number of variable names used within the equation
  */
  public int numDependencies() {
    return dependencies.size();
  }

  /**
    Log an error message
    
    @param  s The error message
  */
  private void error(String s) {
    logger.log(Level.SEVERE,s);
    errorMessages.add(s);
  }

  /**
    Log an error message, including line number
    
    @param  s The message
    @param  line  The line number
    @param  column  The column number at which the error occured
  */
  private void error(String s, int line, int column) {
    String msg = "[" + line + ":" + column + "]" + s;
    logger.log(Level.SEVERE,msg);
    errorMessages.add(msg);
  }

  /**
    Prints stack trace in tab delimited format - operator, arguments, ->, answer
    
    @param  s The message
    @param  d The Datum value containing the answer
  */
  private void debug(String s,Datum d) {
    if (logger.isLoggable(Level.FINE)) {
      if (d == null) {
        logger.log(Level.FINE,s + "[null Datum]");
      }
      else {
        String varName = d.getName();

        logger.log(Level.FINE,((s != null) ? (s + "\t") : "") + "->\t" +
              "'" + d.stringVal(true) + "'\t" +
              d.doubleVal() + "\t" +
              d.dateVal() + "\t" +
              d.monthVal() + "\t" +
              ((varName != null) ? ("VAR_NAME='" + varName + "'") : ""));
      }
    }
  }

  /**
    Returns a formated view of the Datum's value.
    
    @param  d The Datum
    @return The formatted value
    @see Datum
  */
  private String datumValue(Datum d) {
    String varName = d.getName();
    if (varName == null)
      return d.stringVal(true);
    else
      return ("(" + varName + "," + d.stringVal(true) + ")");
  }

  /**
    Returns the name of the operator used to parse the equation, for debugging purposes.
    
    @param  op  The operator
    @return The human-readable name of the operator
  */
  private String opName(int op) {
    return tokenImage[op].substring(1,tokenImage[op].length()-1);
  }

  /**
    Process an unary operator (+,-,!), pushing the result on the stack.
    
    @param  op  The operator
    @param  arg1  it's argument
  */
  private void unaryOp(int op, Object arg1) {
    Datum a = getParam(arg1);
    Datum ans = null;
    switch(op) {
      case PLUS: ans = a; break;
      case MINUS: ans = DatumMath.neg(a); break;
      case NOT: ans = DatumMath.not(a); break;
      default: ans = Datum.getInstance(context,Datum.INVALID); break;
    }
    stackPush(ans);

    if (logger.isLoggable(Level.FINE)) {
      debug(opName(op) + "\t" + datumValue(a),ans);
    }
  }

  /**
    Safely get a Datum, returning INVALID if it is null.
    
    @param  o The parameter
  */
  private Datum getParam(Object o) {
    if (o == null)
      return Datum.getInstance(context,Datum.INVALID);
    return (Datum) o;
  }

  /**
    Process a binary operator (+,-,*,/,>, etc., pushing the result on the stack
    
    @param  op  The operator
    @param  arg2  The right hand side of the equation
    @param  arg1  The left hand side of the equation
  */
  private void binaryOp(int op, Object arg2, Object arg1) {
    Datum a = getParam(arg1);
    Datum b = getParam(arg2);
    Datum ans = null;
    switch(op) {
      case PLUS: ans = DatumMath.add(a,b); break;
      case MINUS: ans = DatumMath.subtract(a,b); break;
      case MULTIPLY: ans = DatumMath.multiply(a,b); break;
      case DIVIDE: ans = DatumMath.divide(a,b); break;
      case GT: ans = DatumMath.gt(a,b); break;
      case GE: ans = DatumMath.ge(a,b); break;
      case EQ: ans = DatumMath.eq(a,b); break;
      case NEQ: ans = DatumMath.neq(a,b); break;
      case LT: ans = DatumMath.lt(a,b); break;
      case LE: ans = DatumMath.le(a,b); break;
      case CONCATENATE: ans = DatumMath.concat(a,b); break;
      case ANDAND: ans = DatumMath.andand(a,b); break;
      case OROR: ans = DatumMath.oror(a,b); break;
      case MODULUS: ans = DatumMath.modulus(a,b); break;
      case XOR: ans = DatumMath.xor(a,b); break;
      case AND: ans = DatumMath.and(a,b); break;
      case OR: ans = DatumMath.or(a,b); break;
      case ASSIGN: context.getDAO().set(a.stringVal(),b); ans = context.getDAO().getDatum(a.stringVal()); break;
      default: ans = Datum.getInstance(context,Datum.INVALID); break;
    }
    stackPush(ans);

    if (logger.isLoggable(Level.FINE)) {
      debug(opName(op) + "\t" + datumValue(a) + "\t" + datumValue(b),ans);
    }
  }

  /**
    Process a ternary operator, like (eqn) ? true : false, pushing the result on the stack
    
    @param  op  The operator
    @param  arg3  The 3rd argument
    @param  arg2  The 2nd argument
    @param  arg1  The 1st argument
  */
  private void trinaryOp(int op, Object arg3, Object arg2, Object arg1) {
    Datum a = getParam(arg1);
    Datum b = getParam(arg2);
    Datum c = getParam(arg3);
    Datum ans = null;
    switch(op) {
      case QUEST: ans = DatumMath.conditional(a,b,c); break;
      default: ans = Datum.getInstance(context,Datum.INVALID); break;
    }
    stackPush(ans);

    if (logger.isLoggable(Level.FINE) ) {
      debug(opName(op) + "\t" + datumValue(a) + "\t" + datumValue(b) + "\t" + datumValue(c),ans);
    }
  }

  /**
    Perform a function on a stack of arguments, pushing the result on the stack
    
    @param  func  The requested function
    @param  params  The stack of parameters
  */
  private void functionOp(Token func, Stack params) {
    Datum ans = context.getDAO().function(context,func.image, params, func.beginLine, func.beginColumn);
    stackPush(ans);

    if (logger.isLoggable(Level.FINE) ) {
      StringBuffer sb = new StringBuffer("function\t" + func.image);
      for (int i=0;i<params.size();++i) {
        Object o = params.elementAt(i);
        if (o == null)
          sb.append("\tnull");
        else if (o instanceof Datum)
          sb.append("\t" + datumValue((Datum) o));
        else if (o instanceof String)
          sb.append("\t" + (String) o);
        else
          sb.append("\t" + o.getClass());
      }
      debug(sb.toString(), ans);
    }
  }

  /**
    Check whether a value matches any of the values in a list.
    
    @param result The value to match
    @param set  The set of objects to search
  */
  private void inListOp(Object result, Stack set) {
    Datum a = getParam(result);
    ArrayList set2 = null;

    if (logger.isLoggable(Level.FINE)) {
      debug("LHS = ", a);
      set2 = new ArrayList(set);
      for (int i=0;i<set.size();++i) {
        debug("RHS[" + i + "] = ", context.getParam(set2.get(i)));
      }
    }

    set2 = new ArrayList(set);
    for (int i=0;i<set.size();++i) {
      Datum b = context.getParam(set2.get(i));
      Datum ans = DatumMath.eq(a,b);
      if (ans.booleanVal() == true) {
        stackPush(new Datum(context, true));
        return;
      }
    }
    stackPush(new Datum(context, false));
  }

  /**
    Push an operator, Datum, or function onto the stack, optionally logging it to the debugger
    
    @param  obj The object to push on the stack
  */
  private void stackPush(Object obj) {
    debug("Push",(Datum) obj);  // XXX:  Can this crash with case to Datum?
    stack.push(obj);
  }

  /**
    Pop an operator, Datum, or function from the stack, optionally logging it to the debugger
    
    @return The object
  */
  private Object stackPop() {
    Object obj = stack.pop();
    debug("Pop", (Datum) obj); // XXX:  Can this crash with cast to Datum?
    return obj;
  }

/**
  Process one or more statements
*/
  final public void Statement() throws ParseException {
                    /*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expressions();
      label_1:
      while (true) {
        if (jj_2_1(2)) {
          ;
        } else {
          break label_1;
        }
        jj_consume_token(SEMICOLON);
        Expressions();
          Object value = stackPop();
          stackPop();  /* throw away the penultimate item on the stack */
          stackPush(value);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      jj_consume_token(0);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process a set of expressions
*/
  final public void Expressions() throws ParseException {
                      /*@bgen(jjtree) Expressions */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        Expression();
          Object value = stackPop();
          stackPop();  /* throw away the penultimate item on the stack */
          stackPush(value);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process a single expression, including conditionals
*/
  final public void Expression() throws ParseException {
                     /*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_2(2)) {
        AssignmentExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case PLUS:
        case MINUS:
        case NOT:
        case LP:
        case LSB:
        case LCB:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case NMTOKEN:
          ConditionalExpression();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a = result"
*/
  final public void AssignmentExpression() throws ParseException {
                              /*@bgen(jjtree) AssignmentExpression */
                               SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTEXPRESSION);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(NMTOKEN);
              t = token;
      jj_consume_token(ASSIGN);
      ConditionalExpression();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      binaryOp(ASSIGN,stackPop(), new Datum(context, t.image,Datum.STRING));
      dependencies.put(t.image,t.image);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "(exp) ? true : false"
*/
  final public void ConditionalExpression() throws ParseException {
                                /*@bgen(jjtree) ConditionalExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      LogicalORExpression();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case QUEST:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_3;
        }
        jj_consume_token(QUEST);
        LogicalORExpression();
        jj_consume_token(COLON);
        LogicalORExpression();
          trinaryOp(QUEST,stackPop(),stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a || b"
*/
  final public void LogicalORExpression() throws ParseException {
                              /*@bgen(jjtree) LogicalORExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTLOGICALOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      LogicalANDExpression();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OROR:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_4;
        }
        jj_consume_token(OROR);
        LogicalANDExpression();
          binaryOp(OROR,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a && b"
*/
  final public void LogicalANDExpression() throws ParseException {
                               /*@bgen(jjtree) LogicalANDExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTLOGICALANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      InclusiveORExpression();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ANDAND:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_5;
        }
        jj_consume_token(ANDAND);
        InclusiveORExpression();
          binaryOp(ANDAND,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process an expression like "a || b"
*/
  final public void InclusiveORExpression() throws ParseException {
                                /*@bgen(jjtree) InclusiveORExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTINCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ExclusiveORExpression();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_6;
        }
        jj_consume_token(OR);
        ExclusiveORExpression();
          binaryOp(OR,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a | b"
*/
  final public void ExclusiveORExpression() throws ParseException {
                                /*@bgen(jjtree) ExclusiveORExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXCLUSIVEOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ANDExpression();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case XOR:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_7;
        }
        jj_consume_token(XOR);
        ANDExpression();
          binaryOp(XOR,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a & b"
*/
  final public void ANDExpression() throws ParseException {
                        /*@bgen(jjtree) ANDExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      EqualityExpression();
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_8;
        }
        jj_consume_token(AND);
        EqualityExpression();
          binaryOp(AND,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a == b" and "a != b"
*/
  final public void EqualityExpression() throws ParseException {
                             /*@bgen(jjtree) EqualityExpression */
                              SimpleNode jjtn000 = new SimpleNode(JJTEQUALITYEXPRESSION);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token op;
    try {
      InListExpression();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
        case NEQ:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EQ:
          jj_consume_token(EQ);
          break;
        case NEQ:
          jj_consume_token(NEQ);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                         op = token;
        InListExpression();
          binaryOp(op.kind,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a in (b,c,d,e)"
*/
  final public void InListExpression() throws ParseException {
                           /*@bgen(jjtree) InListExpression */
                            SimpleNode jjtn000 = new SimpleNode(JJTINLISTEXPRESSION);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);Token op; Stack params;
    try {
      RelationalExpression();
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IN:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_10;
        }
        jj_consume_token(IN);
        jj_consume_token(LP);
        params = FunctionParameters();
        jj_consume_token(RP);
          inListOp(stackPop(),params);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a op b" where op in {lt, gt, le, ge)
*/
  final public void RelationalExpression() throws ParseException {
                               /*@bgen(jjtree) RelationalExpression */
                                SimpleNode jjtn000 = new SimpleNode(JJTRELATIONALEXPRESSION);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);Token op;
    try {
      AdditiveExpression();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GT:
        case GE:
        case LT:
        case LE:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_11;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          jj_consume_token(LT);
          break;
        case GT:
          jj_consume_token(GT);
          break;
        case LE:
          jj_consume_token(LE);
          break;
        case GE:
          jj_consume_token(GE);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                      op = token;
        AdditiveExpression();
          binaryOp(op.kind,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a op b" where op in (+,-,concatenate)
*/
  final public void AdditiveExpression() throws ParseException {
                             /*@bgen(jjtree) AdditiveExpression */
                              SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token op;
    try {
      MultiplicativeExpression();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
        case MINUS:
        case CONCATENATE:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_12;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          break;
        case CONCATENATE:
          jj_consume_token(CONCATENATE);
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                             op = token;
        MultiplicativeExpression();
          binaryOp(op.kind,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "a op b" where op in (*,/)
*/
  final public void MultiplicativeExpression() throws ParseException {
                                   /*@bgen(jjtree) MultiplicativeExpression */
                                    SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);Token op;
    try {
      UnaryExpression();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
        case DIVIDE:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_13;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MULTIPLY:
          jj_consume_token(MULTIPLY);
          break;
        case DIVIDE:
          jj_consume_token(DIVIDE);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                  op = token;
        UnaryExpression();
          binaryOp(op.kind,stackPop(),stackPop());
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process "op a" where op in (+,-,!)
*/
  final public void UnaryExpression() throws ParseException {
                          /*@bgen(jjtree) UnaryExpression */
                           SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);Token op;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
      case NOT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        case MINUS:
          jj_consume_token(MINUS);
          break;
        case NOT:
          jj_consume_token(NOT);
          break;
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                               op = token;
        PrimaryExpression();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      unaryOp(op.kind,stackPop());
        break;
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LP:
      case LSB:
      case LCB:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NMTOKEN:
        PrimaryExpression();
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process an expression, including functions 
*/
  final public void PrimaryExpression() throws ParseException {
                            /*@bgen(jjtree) PrimaryExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_3(2)) {
        Function();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
          Constant();
          break;
        case NMTOKEN:
          jj_consume_token(NMTOKEN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      Datum d = context.getDAO().getDatum(token.image);
      if (d == null) {
        error(context.get("undefined_variable") + " '" + token.image + "'", token.beginLine, token.beginColumn);
        stackPush(Datum.getInstance(context,Datum.INVALID));
      }
      else {
        stackPush(d);
      }
      dependencies.put(token.image,token.image);  // pushes the name of the variables references within the equation.

          break;
        case LP:
          jj_consume_token(LP);
          Expressions();
          jj_consume_token(RP);
          break;
        case LCB:
          jj_consume_token(LCB);
          Expressions();
          jj_consume_token(RCB);
          break;
        case LSB:
          jj_consume_token(LSB);
          Expressions();
          jj_consume_token(RSB);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process a constant, including strings
*/
  final public void Constant() throws ParseException {
                   /*@bgen(jjtree) Constant */
  SimpleNode jjtn000 = new SimpleNode(JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
          jj_consume_token(INTEGER_LITERAL);
          break;
        case FLOATING_POINT_LITERAL:
          jj_consume_token(FLOATING_POINT_LITERAL);
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      stackPush(new Datum(context, token.image,Datum.NUMBER));
        break;
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          jj_consume_token(STRING_LITERAL);
          break;
        case CHARACTER_LITERAL:
          jj_consume_token(CHARACTER_LITERAL);
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      /* replace special characters before storing value */
      StringBuffer sb = new StringBuffer();
      char c;
      int i=0;

      try {
        for (i=1;i<token.image.length()-1;++i) {
          c = token.image.charAt(i);
          if (c == '\\') {
            c = token.image.charAt(++i);
            switch (c) {
              case 'b': sb.append('\b'); break;
              case 'f': sb.append('\f'); break;
              case 'n': sb.append('\n'); break;
              case 'r': sb.append('\n'); break;
              case 't': sb.append('\t'); break;
              case '\'': sb.append('\''); break;
              case '\"': sb.append('\"'); break;
              case '\\': sb.append('\\'); break;
              default: sb.append(c); break;
            }
          }
          else {
            sb.append(c);
          }
        }
      }
      catch (IndexOutOfBoundsException e) {
        error(context.get("unterminated_escaped_character"), token.beginLine, token.beginColumn + i);
      }

      stackPush(new Datum(context, sb.toString(),Datum.STRING));
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Process a function, passing the FunctionParameters as a stack to Functions.function
*/
  final public void Function() throws ParseException {
                   /*@bgen(jjtree) Function */
                    SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t; Stack params;
    try {
      jj_consume_token(NMTOKEN);
              t = token;
      jj_consume_token(LP);
      params = FunctionParameters();
      jj_consume_token(RP);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      functionOp(t,params);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

/**
  Assemble the stack of function parameters.
  
  @return The stack of parameters
*/
  final public Stack FunctionParameters() throws ParseException {
                              /*@bgen(jjtree) FunctionParameters */
                               SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONPARAMETERS);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);Stack params = new Stack();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case PLUS:
      case MINUS:
      case NOT:
      case LP:
      case LSB:
      case LCB:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case NMTOKEN:
        Expression();
      params.push(stackPop());
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[24] = jj_gen;
            break label_14;
          }
          jj_consume_token(COMMA);
          Expression();
        params.push(stackPop());
        }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return params;}
        break;
      default:
        jj_la1[25] = jj_gen;
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return params;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(2)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_31()) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    return false;
  }

  final private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    }
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_scan_token(NMTOKEN)) return true;
    if (jj_scan_token(LP)) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(LSB)) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(LCB)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(LP)) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_22()) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_scan_token(NMTOKEN)) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_3R_15()) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    }
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_scan_token(NMTOKEN)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  public DialogixParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[26];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x2000000,0x5400003e,0x800000,0x10000,0x8000,0x100000,0x40000,0x80000,0xc00,0xc00,0x400000,0x3300,0x3300,0x4018,0x4018,0xc0,0xc0,0x38,0x5400003e,0x54000006,0x0,0x6,0x6,0x2000000,0x5400003e,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x1,0x0,0xa20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa20,0xa20,0x220,0x0,0x220,0x0,0xa20,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[3];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public DialogixParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public DialogixParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new DialogixParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public DialogixParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DialogixParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public DialogixParser(DialogixParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(DialogixParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[44];
    for (int i = 0; i < 44; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 26; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 44; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 3; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
